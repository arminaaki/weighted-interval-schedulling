#!/usr/bin/env python


import sys
from collections import defaultdict


class Job:

    def __init__(self, index, job_details):
        self.start_time, self.finish_time, self.cost = job_details
        self.index = index

    def __repr__(self):
        return "(" + str(self.start_time) + ", " + str(self.finish_time) + ", " + str(self.cost) + ")"

    def __eq__(self, other):
        return self.start_time == other.start_time and self.finish_time == other.finish_time and self.cost == other.cost

    def __ne__(self, other):
        return not self.__eq__(other)


class JobManager:

    def __init__(self):
        self.jobs_sorted_by_finish_time = []
        self.read_jobs()
        self.OPTIMAL = defaultdict(lambda: None)

    def read_jobs(self):
        counter = 0
        with open("sample_data/ex4", "r") as ins:
            for line in ins:  # sys.stdin:
                self.jobs_sorted_by_finish_time.append(
                    Job(counter, [int(i) for i in line.split()]))
                ++counter
        self.jobs_sorted_by_finish_time.sort(key=lambda job: job.finish_time)

    def job_size(self):
        return len(self.jobs_sorted_by_finish_time)

    def binary_search(self, low, high, job,  out):
        mid_point = (low + high) / 2
        if(low >= mid_point):
            return
        # and self.jobs_sorted_by_finish_time[mid_point] != job:
        if self.jobs_sorted_by_finish_time[mid_point].finish_time <= job.start_time:
            out.pop() if out else True
            out.append(mid_point)
            self.binary_search(mid_point, high, job, out)
        else:
            self.binary_search(low, mid_point, job, out)

    def find_largest_non_overlapping_job(self, job):
        out = [0]
        self.binary_search(0, self.job_size() - 1, job, out)
        return out[-1]

    def find_largest_index_for_none_overlapping_job(self, index):
        out = [0]
        self.binary_search(0, self.job_size() - 1,
                           self.jobs_sorted_by_finish_time[index], out)
        return out[-1]

    def compute_optimal(self, i):
        if(i == 0):
            return 0
        elif self.OPTIMAL[i] != None:
            return self.OPTIMAL[i]
        else:
            print(i)
            non_overlapping_index = self.find_largest_non_overlapping_job(
                self.jobs_sorted_by_finish_time[i])
            x = self.jobs_sorted_by_finish_time[
                i].cost + self.compute_optimal(non_overlapping_index)
            y = self.compute_optimal(i - 1)
            self.OPTIMAL[i] = max(x, y)
            return self.OPTIMAL[i]

    def compute_optimal2(self, n):
        self.OPTIMAL[0] = 0
        for i in range(1, n):
            self.OPTIMAL[i] = max(self.jobs_sorted_by_finish_time[i].cost + self.OPTIMAL[
                                  self.find_largest_non_overlapping_job(self.jobs_sorted_by_finish_time[i])], self.OPTIMAL[i - 1])
        return self.OPTIMAL[n - 1]

    def find_optimal_path(self):
        iteration = self.job_size() - 1
        out = []
        while (iteration > 0):
            non_overlapping_index = self.find_largest_index_for_none_overlapping_job(
                iteration)
            if(self.jobs_sorted_by_finish_time[iteration].cost + self.OPTIMAL[non_overlapping_index] > self.OPTIMAL[iteration - 1]):
                out.append(self.jobs_sorted_by_finish_time[iteration])
                iteration = non_overlapping_index
            else:
                iteration -= 1
        return out

    def print_optimal_path(self):
        sum = 0
        for job in reversed(self.find_optimal_path()):
            print job

manager = JobManager()
input = manager.jobs_sorted_by_finish_time[4]
# print(manager.jobs_sorted_by_finish_time)
# print(input)
# print(manager.find_largest_non_overlapping_job(input))
print(manager.compute_optimal2(manager.job_size()))
manager.print_optimal_path()
